#include <iostream>
#include <utility>  // for std::forward

void process(int& x) {
    std::cout << "Lvalue processed: " << x << std::endl;
}

void process(int&& x) {
    std::cout << "Rvalue processed: " << x << std::endl;
}

template <typename T>
void wrapper(T&& val) {
    process(std::forward<T>(val));  // Perfectly forwards the value category
}

int main() {
    int x = 42;
    wrapper(x);          // Calls process(int&) because x is an lvalue
    wrapper(99);         // Calls process(int&&) because 99 is an rvalue

    return 0;
}



std::forward is used in template functions to perfectly forward arguments while preserving their original value category (whether they were originally an lvalue or rvalue).

It is used to ensure that when forwarding arguments, lvalues stay as lvalues and rvalues stay as rvalues.

std::forward only works with forwarding references (also known as "universal references"), i.e., when the argument type is deduced and is of type T&& in a template.

It is essential for perfect forwarding in generic code, where you want to forward arguments without changing their type or value category.






#include <iostream>
#include <vector>
#include <utility>  // for std::move

void process(std::vector<int>& v) {
    std::cout << "Lvalue processed\n";
}

void process(std::vector<int>&& v) {
    std::cout << "Rvalue processed\n";
}

int main() {
    std::vector<int> vec = {1, 2, 3};

    process(vec);             // Calls lvalue version
    process(std::move(vec));  // Calls rvalue version

    return 0;
}

process(vec) uses the lvalue reference overload.

process(std::move(vec)) casts vec to an rvalue reference, enabling the rvalue overload of process and allowing move semantics.



#include <iostream>
#include <vector>
#include <utility>  // for std::move and std::forward

// Move constructor
class MyClass {
public:
    MyClass() = default;
    MyClass(MyClass&& other) {
        std::cout << "Move Constructor\n";
    }
};

// Template to forward arguments
template <typename T>
void wrapper(T&& val) {
    // Forward the argument while preserving its value category
    MyClass obj = std::forward<T>(val);  // Move or copy depending on the value category
}

int main() {
    MyClass x;
    wrapper(x);            // Lvalue forwarded as lvalue (copy)
    wrapper(MyClass());    // Rvalue forwarded as rvalue (move)

    return 0;
}

std::move is used to cast an lvalue into an rvalue reference, enabling move semantics in a function.

std::forward is used in template functions to perfectly forward arguments while preserving their original type (lvalue or rvalue).

std::move should be used when you explicitly want to "move" an object, and std::forward should be used when you want to forward arguments in a template while preserving their value category.